% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils.R
\name{wb_dims}
\alias{wb_dims}
\title{Helper to specify the \code{dims} argument.}
\usage{
wb_dims(...)
}
\arguments{
\item{...}{construct dims arguments, from rows/cols vectors or objects that
can be coerced to data frame}
}
\value{
A \code{dims} string
}
\description{
\code{wb_dims()} can be used to help provide the \code{dims} argument, in the \verb{wb_add_*} functions.
It returns a Excel range (i.e. "A1:B1") or a start like "A2".
It can be very useful as you can specify many parameters that interact together
In general, you must provide named arguments. \code{wb_dims()} will only accept unnamed arguments
if it is \code{rows}, \code{cols}, for example \code{wb_dims(1:4, 1:2)}, that will return "A1:B4".

\code{wb_dims()} can also be used with an object (a \code{data.frame} or a \code{matrix} for example.)
All parameters are numeric unless stated otherwise.
}
\details{
\code{wb_dims()} tries to support most possible cases with \code{row_names = TRUE} and \code{col_names = FALSE},
but it works best if \code{x} has named dimensions (\code{data.frame}, \code{matrix}), and those parameters are not specified.
data with column names, and without row names. as the code is more clean.

In the \code{add_data()} / \code{add_font()} example, if writing the data with row names

\if{html}{\out{<div class="sourceCode r">}}\preformatted{dims_row_names <- wb_dims(x = mtcars, row_names = TRUE, col_names = FALSE, cols = 0)
# add data to an object with row names
wb <- wb_workbook()
wb$add_worksheet("test")
full_mtcars_dims <-
wb$add_data(x = mtcars, dims = wb_dims(x = mtcars, row_names = TRUE), row_names = TRUE)
# Style row names of an object (many options)
# The programmatic way to access row names only with `x` is
dims_row_names <- wb_dims(x = mtcars, row_names = TRUE, col_names = FALSE, cols = 0, from_col = 0)
# In this case, it's much better to use a simpler alternative without using `x`
dims_row_names <- wb_dims(cols = "A", from_row = 2)
dims_row_names <- wb_dims(2:33, 1) # or dims <- "A2:A33"
dims_row_names <- "A2:A33" # or simply "A2"
wb$add_font(dims = dims_row_names, bold = TRUE)
# the following would work too, but `wb_dims()` may be longer to write, but easier to read after, as
# it can make it clear which object is affected
wb$add_font(dims = dims_row_names, bold = TRUE)

}\if{html}{\out{</div>}}
}
\section{Using \code{wb_dims()} without an \code{x} object}{
\itemize{
\item \code{rows} / \code{cols} (if you want to specify a single one, use \code{from_row} / \code{from_col})
\item \code{from_row} / \code{from_col} the starting position of the \code{dims}
}
}

\section{Using \code{wb_dims()} with an \code{x} object}{
When using \code{wb_dims()} with an object, the default behavior is to select only the data / row or columns in \code{x}
If you need another behavior, use \code{wb_dims()} without supplying \code{x}.
\itemize{
\item \code{x} An object (typically a \code{matrix} or a \code{data.frame}, but a vector is also accepted.)
\item \code{from_row} / \code{from_col} the starting position of \code{x} (The \code{dims} returned will assume that the top left corner of \code{x} is at \code{from_row / from_col}
\item \code{rows} Optional Which row span in \code{x} should this apply to. if \code{rows} = 0, only column names will be affected.
\item \code{cols} a range of columns id in \code{x}, or one of the column names of \code{x} (length 1 only accepted in this case.)
\item \code{row_names} A logical, this is to let \code{wb_dims()} know that \code{x} has row names or not. If \code{row_names = TRUE}, \code{wb_dims()} will increment \code{from_col} by 1.
\item \code{col_names} \code{wb_dims()} assumes that if \code{x} has column names, then trying to find the \code{dims}.
Otherwise, you have to use \code{from_row = 0}. (not yet fully supported.). You can use \code{unname(x)} to give better input
}
}

\examples{
wb_dims(x = mtcars, row_names = TRUE, col_names = FALSE, cols = 0)
# Provide coordinates
wb_dims()
wb_dims(1, 4)
wb_dims(rows = 1, cols = 4)
wb_dims(from_row = 4)
wb_dims(from_col = 2)
wb_dims(1:4, 6:9, from_row = 5)
# Provide vectors
wb_dims(1:10, c("A", "B", "C"))
wb_dims(rows = 1:10, cols = 1:10)
# provide `from_col` / `from_row`
wb_dims(rows = 1:10, cols = c("A", "B", "C"), from_row = 2)
wb_dims(rows = 1:10, cols = 1:10, from_col = 2)
# or objects

wb_dims(x = mtcars)
# column names of an object (with the special `rows = 0`)
wb_dims(x = mtcars, rows = 0)
# usually, it's better
# dims of all the data of mtcars.
wb_dims(x = mtcars, col_names = FALSE)

# dims of the column names of an object
wb_dims(x = mtcars, rows = 0, col_names = TRUE)

## add formatting to column names with the help of `wb_dims()` ====
wb <- wb_workbook()
wb$add_worksheet("test")
wb$add_data(x = mtcars, dims = wb_dims(x = mtcars))
# Style col names of an object to bold (many options)
\dontrun{
wb <- wb_workbook()
# Supplying dims using x
dims_column_names <- wb_dims(x = mtcars, rows = 0)
wb$add_font(dims = dims_column_names, bold = TRUE)

# Finally, to add styling to column "cyl" (the 4th column)
# there are many options, but here is the preferred one
# if you know the column index, wb_dims(x = mtcars, cols = 4) also works.
dims_cyl <- wb_dims(x = mtcars, cols = "cyl")
wb$add_font(dims = dims_cyl, color = wb_color("red"))
}
}
